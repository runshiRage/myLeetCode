package com.winding_month.practice_001;

/**
 * 构建二叉树
 *                 1
 *         --------|-------
 *         2               3
 *     ----|----       ----|----
 *     4       5       6       7
 *
 * 前序遍历 1245367
 * 中序遍历 4251637
 * 后续遍历 4526731
 *
 * 以上面那棵二叉树为例，我们可以发现，对于后序遍历来说，最后一个元素一定是根节点，也就是1。
 * 然后我们在中序遍历的结果里面找到1所在的位置，那么它的左半部分就是其左子树，有半部分就是其右子树。
 *
 * 我们将中序遍历左半部分425取出，同时发现后序遍历的结果也在相应的位置上面，只是顺序稍微不一样，也就是452。
 * 我们可以发现，后序遍历中的2就是该子树的根节点。
 *
 * 上面说到了左子树，对于右子树，我们取出637，同时发现后序遍历中对应的数据偏移了一格，并且顺序也不一样，为673。
 * 而3就是这颗右子树的根节点。
 *
 * 重复上述过程，通过后续遍历找到根节点，然后在中序遍历数据中根据根节点拆分成两个部分，
 * 同时将对应的后序遍历的数据也拆分成两个部分，重复递归，就可以得到整个二叉树了
 *
 */
public class GenerateTree {

    /**
     *
     * @param inorder   中序
     * @param postorder   后序
     */
    private void generate(int[] inorder, int[] postorder) {
        
    }
}
